// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model Topic {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  content   String
  description String   @default("")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  collectionIds String[] @db.ObjectId

  @@index([name(sort: Asc), content(sort: Asc), description(sort: Asc)], map: "search_text_index")
  @@map("topics")
}

// Note the collectionIds are for MongoDB, where I'm using an array of references instead of a direct relation


model Collections {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  name         String
  description  String?
  topicIds     String[] @db.ObjectId
  publishedUrl String?
  hashnodeUrl  String?
  devToUrl     String?
  createdAt    DateTime @default(now())
  lastEdited   DateTime @updatedAt

  @@index([name(sort: Asc), description(sort: Asc)], map: "search_text_index")
  @@map("collections")
}

model PublishedContent {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  fileName  String
  content   String
  createdAt DateTime @default(now())

  @@map("publishedContent")
}

model MediaItem {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  filename  String
  url       String
  size      Int
  mimeType  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("mediaItems")
}
model Settings {
  id              String    @id @default(auto()) @map("_id") @db.ObjectId
  hashnodeToken   String?
  publicationId   String?
  lastUpdated     DateTime  @updatedAt
  
  @@map("settings")
}

model Campaign {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  name        String
  description String?
  startDate   DateTime?
  endDate     DateTime?
  status      String    @default("draft") // draft, active, completed, archived
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishingPlans PublishingPlan[]

  @@map("campaigns")
}

model Webhook {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  userId    String
  name      String
  url       String
  events    String[]
  enabled   Boolean   @default(true)
  secret    String?
  headers   Json?
  retryCount Int      @default(3)
  retryDelay Int      @default(1000)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deliveries WebhookDelivery[]

  @@map("webhooks")
}

model WebhookDelivery {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  webhookId String    @db.ObjectId
  webhook   Webhook   @relation(fields: [webhookId], references: [id])
  event     String
  url       String
  payload   Json
  status    String    // success, failed, pending
  statusCode Int?
  response  Json?
  error     String?
  attempts  Int       @default(1)
  createdAt DateTime  @default(now())

  @@map("webhook_deliveries")
}

model AnalyticsEvent {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  eventType   String    // page.view, content.view, content.read, etc
  contentId   String?   @db.ObjectId
  campaignId  String?   @db.ObjectId
  platform    String?
  sessionId   String
  visitorId   String?   // Privacy-safe, rotates daily
  
  // Event metadata
  metadata    Json?
  device      Json?     // { type, os, browser }
  geo         Json?     // { country, region }
  
  timestamp   DateTime  @default(now())
  
  // Indexes for efficient queries
  @@index([contentId, timestamp])
  @@index([campaignId, timestamp])
  @@index([eventType, timestamp])
  @@index([visitorId, timestamp])
  @@index([sessionId])
  @@map("analytics_events")
}

model AnalyticsAggregate {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  
  // Aggregation dimensions
  contentId   String?   @db.ObjectId
  campaignId  String?   @db.ObjectId
  platform    String?
  date        DateTime  // Date for daily aggregates
  hour        Int?      // Hour for hourly aggregates (0-23)
  
  // Aggregated metrics
  views       Int       @default(0)
  reads       Int       @default(0)
  completions Int       @default(0)
  shares      Int       @default(0)
  uniqueVisitors Int    @default(0)
  
  // Time-based metrics
  totalReadTime    Int @default(0) // Total seconds
  avgReadTime      Int @default(0) // Average seconds
  totalScrollDepth Int @default(0) // Sum of scroll depths
  avgScrollDepth   Int @default(0) // Average scroll depth
  
  // Engagement metrics
  engagementRate   Float @default(0)
  clickThroughRate Float @default(0)
  completionRate   Float @default(0)
  
  // Geographic data
  topCountries    Json? // Array of {country, visitors, percentage}
  
  // Metadata
  aggregatedAt DateTime @default(now())
  
  // Indexes for efficient queries
  @@index([contentId, date])
  @@index([campaignId, date]) 
  @@index([platform, date])
  @@index([date, hour])
  @@unique([contentId, campaignId, platform, date, hour])
  @@map("analytics_aggregates")
}

model PublishingPlan {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  campaignId  String    @db.ObjectId
  topicId     String    @db.ObjectId
  platform    String    
  status      String    @default("scheduled") 
  scheduledFor DateTime?
  publishedAt DateTime?
  publishedUrl String?
  hashnodeUrl String?  // Add this
  devToUrl    String?  // Add this
  beehiivUrl  String?  // Add this
  campaign    Campaign  @relation(fields: [campaignId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([campaignId, topicId, platform])
  @@map("publishingPlans")
}